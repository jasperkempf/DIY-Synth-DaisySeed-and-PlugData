---
layout: default
title: 05.3 Modulation
parent: 05 Programming a Synthesizer
nav_order: 3
---

# 05.3 - Modulation

> You can download all example patches <a href="{{ site.baseurl }}/assets/diy-synth-example-files.zip" download>here</a>

To expand the sound design possibilities of our Instrument, we'll have a look at implementing two different types of modulation – LFOs (low frequency oscillators) and Envelopes. Both can technically be used to modulate any thinkable parameter of a synth. While LFOs describe a modulation curve, that is running permanently (unless configured otherwise) at the set Rate or frequency, an envelope is typically triggered by incoming note-on and note-off events (typically transmitted through MIDI-Data).

## LFOs (Pd04-LFO-Example.pd)

Our example Patch _Pd04-LFO-Example.pd_ is a simple patch, that lets us select different LFO-waveshapes and visualizes them for demonstrative purposes with a `scope~`. Changing the waveform via the bang and altering the frequency via the slider gives us a better understanding of the underlying signal generation that is taking place in the subpatch.

<img width="540" alt="05-03-LfoExample" src="https://github.com/user-attachments/assets/e3ecee31-24da-4b6e-b277-1bde53ae20ff" />

Opening the subpatch `pd LFOs`, we can see that the different LFO-waveforms are generated by 5 `hv.lfo `-objects, configured for the different waveforms sine, ramp, saw, triangle and square. The same counter and route mechanism is used to select activate and deactivate the waveforms upon selection. As the `hv.lfo `-object does not create a signal-output but a float, we cannot employ the simple signal-multiplication to turn it on and off (as we did with our oscillators). 

Instead, i used the `spigot`-object. This is a handy object with two inputs and one output. The right input controls, wether the input on the left inlet is let through the outlet or if it's blocked. Via the `1 ` and `0 ` messages, we can now control which LFO is sent out of the subpatch.

<img width="540" alt="Bildschirmfoto 2025-04-29 um 11 36 44" src="https://github.com/user-attachments/assets/677c1b6c-7afe-4afe-a9fd-db25d2871a66" />

In the main patch, the float outlet of the subpatch is converted into a signal-stream by using a `sig~`-object. This allows us to use the generated waveform to modulate any parameter, such as the frequency or the amplitude of an oscillator.

### Simple Frequency Modulation (Pd05-SimpleFM.pd)

The example Patch _Pd05-SimpleFM.pd_ shows how we can simply use this LFO-Selector to modulate the frequency of an oscillator. By using the `+~ `-object, we can add the LFO-signal and the Oscillater-Frequency signal, before it's transmitted to the `hv.osc sine~`-object.

As the Amplitude of the LFO moves between 0 and 1, the modulation range is too low for modulating the frequency of an oscillator, as it wouldn't create an audible result. I added the FM Depth-control to extend the range from between 0 and a maximum of 3000. This will allow us to have a modulation range of up to +3000Hz for our oscillator pitch. 

<img width="540" alt="05-03-SimpleFM" src="https://github.com/user-attachments/assets/15a2a62f-67d4-4f3d-9275-01252b0706ef" />

### Frequency Modulation 2 (Pd06-OscFM.pd)

This is a great way for modulating the frequency at lower rates (which an LFO is designed for in the first place). However, for modulating the pitch of an oscillator at higher frequencies, the `hv.lfo`-generators didn't provide results that were clean enough to produce pleasant harmonics. I assume, this is introduced by the float-to-signal conversion.

This was unfortunate to discover, as I found the implementation of this functionality particularly desirable, as it offers the possibility of creating more complex sounding characteristics out of simple waveforms. So instead of using `hv.lfo `, i decided to use `hv.osc~ `-generators for high frequency modulation applications. The Patch _Pd06-OscFM.pd_ shows an example of how similar results as with `hv.lfo ` can be achieved with `hv.osc~ `. 

<img width="540" alt="05-03-OscFM" src="https://github.com/user-attachments/assets/c4c4c913-1f0a-44dc-9edb-8f271b18edf9" />

The subpatch _FmEngine_ shows, how the different `hv.osc~ ` generators are activated and controlled.

<img width="540" alt="05-03-OscFm-Subpatch" src="https://github.com/user-attachments/assets/97a50e6b-9c65-428f-8050-825ff6f4f69a" />

The downside of this method is, that there are less waveforms available with the `hv.osc~ `-objects than with the `hv.lfo `-generator. If you're planning to implement a "classic" LFO for low frequency modulation, the `hv.lfo ` will be a great choice with a broader selection of available waveforms.

### Amplitude Modulation (Pd07-SimpleAM.pd)

To use our LFO to modulate the amplitude of a signal, we can simply multiply the source signal with our modulator signal using `*~ `. As opposed to our Frequency-Modulation, where we extended the modulation range, this is not necessarily required with amplitude modulation as it already operates between 0 and 1. As you can see in the two `scope~`-objects, the signal multiplication causes the output of the oscillator to follow the amplitude of the LFO-waveform. 

<img width="540" alt="05-03-SimpleAM" src="https://github.com/user-attachments/assets/ef65f3a8-7083-40cb-8f38-1ae84c396feb" />

Feel free to open the example patches and play around with it to get a better understanding of how they work!

## Envelopes (Pd.08-Envelope.pd)

To change the character of played notes, we'll have a look of implementing a simple Amplitude-Envelope. The patch _Pd.08-Envelope.pd_ gives an example of what that can look like with a simple Attack-Release Envelope. Activating the sequencer in the top-left of the patch will play a simple 4-Note sequence on loop, which will allow us to hear the effects of tweaking the Attack and Release parameters. As visualized in the `scope~`, these two parameters alter the envelope of the played note by either fading it in and out (long attack and release values), or make the volume changes very abrupt (short attack and release values). As an alternative to the sequencer, you can receive MIDI from an outside source (such as a DAW) or hook up a MIDI controller to play notes (needs to be configured in the Plug Data preferences -> MIDI).

<img width="540" alt="Bildschirmfoto 2025-04-29 um 15 23 42" src="https://github.com/user-attachments/assets/0264f26a-7674-4092-9bef-4a8a9f76ef00" />

Opening the subpatch `pd AR Envelope` gives us an impression of how the envelope is generated. Heart of the patch is the `hv.vline~`-object, which is the signal ramp generator. The `hv.vline~`-object will be receive a pair of two numbers coming from a message box storing two variables `$1 $2`. These two variables store the velocity and a time value in milliseconds, telling the `hv.vline~` to reach the target value of `$1` in the defined time of `$2`. These two values come from the main patch and are packed into a list by the `pack f f`-object. 

As you can see we have two pairs of `pack f f` and `$1 $2`-objects. The left pair defines the attack-time and target value (based on incoming velocity), the right pair the release-time.

As Plug Data does not have note-off events – which would be used to trigger the release of a note – I used the velocity value of `0` as trigger for the release. The `select 0`-object will filter an incoming value of 0, which will trigger the release-time and pass it onto the `hv.vline~`-object. All non-zero velocity values will trigger the attack, causing an audible output from the main patch.

 <img width="540" alt="05-03-EnvSubpatch" src="https://github.com/user-attachments/assets/ecccd481-b154-4e0c-82cf-34823330d283" />

Continue with integrating Polyphony [here]({{site.baseurl}}/chapter-05/05-4-polyphony)!







